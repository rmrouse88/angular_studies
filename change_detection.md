## Change Detection cycle

By default, change detection in Angular is triggered by almost any event you can think of:
- DOM events
- XML/fetch requests completing

Moreover, the location of the event within your application is not important.  An event that occurs in a deeply nested view at the furthest reaches of your application tree or close to the application root will both triggger change detection.

Before going any further, keep this in your mind:

<b><i>An Angular application is a tree of views</i></b>

# applicationRef.tick()

A triggering event will (after passing through several zones) fire ```ApplicationRef.tick()```.

This method will call the ```detectChanges()``` method of the <b><i>root</i></b> view.  Soon after, the first ```checkAndUpdateView()``` method is fired.

<b>TAKEAWAY:</b>Change detection starts at the application root and, more explicitly, <b><i>the root view</i></b>.

## checkAndUpdateView()
- One of the workhorses of both view initialization <i>and</i> change detection
- Manages the cycling of lifecycle hooks
#### markProjectedViewsForCheck()
#### Services.updateDirectives()
  directives are those 
#### execEmbeddedViewActions()
    there are two types of views:  
      1) Host Views - associated with a component
      2) Embedded Views - associated with a directive
#### callLifecycleHooksChildrenFirst
#### updateRenderer(_ck, _v)
  - _ck = check function, _v = view
  - most of the body of the updateRenderer is generated by Angular during the initial app load; it is populated with "hard-coded" variable declarations that are initialized on first load and during subsequent change detection passes to reflect current model state
  - makes sense that updateRenderer must be able to handle changes to the check function and the view during the application run-time (hence why they are passed as args)
  
 ```JavaScript
 //example of updateRenderer() body
 var co = _v.component;
 var currVal_0 = co.property0;
 var currVal_1 = co.property1;
 ...
 var currVal_N = co.propertyN;
 _ck(view, nodeIndex, argStyle, currVal_0, currVal_1...curVal_N);   
 ```
##### debugCheckRenderFn
  route to an appropriate checkAndUpdate function based on the checkType passed to debugUpdateRenderer
  1) debugCheckAndUpdateNode
  2) dbeugCheckNoChangesNode
  
#### debugCheckAndUpdateNode
  - First calls ```checkAndUpdateNode()``` to determine if there were changes to the model
  
  - so what the hell is it using to compare "old values" against new model values?
  
  - Well, remember that the directives in a view are updated prior to calling updateRenderer().  The directives attach themselves to the    'component' property of their parent node.  This loosely associates the model state with the view, but the view must then be updated to reflect these changes.  
  
  - if ```checkAndUpdateNode()``` returns ```true```, the interpolated properties have already been updated in the completed call to checkAndUpdateTextInline()
  
  - debugCheckAndUpdateNode now moves on to updating the attributes on the parent DOM element 
  
##### checkAndUpdateNode
  routes to one of: 
  - checkAndUpdateNodeInline - if argStyle = 'inline' 
  
  - checkAndUpdateNodeDynamic  - otherwise

###### checkAndUpdateNodeInline
  routes to a checkerAndUpdater based on the type of node
  
###### checkAndUpdateTextInline(view:ViewData, def: NodeDef, bindingIdx: number, value: any): boolean
  - giant switchboard checking all available binding indices associated with the current node's bindings
  - calls checkAndUpdateBinding for up to 10 binding values associated with a model
  - once finished updating the node's ```oldValues```, it moves on to rendering the updates in the associated DOM node

###### checkAndUpdateBinding(view:ViewData, def: NodeDef, bindingIdx: number, value: any): boolean
- calls checkBinding to establish a binding has changed
- if checkBinding returns ```true```, the view node's ```oldValues``` array is updated to include the changed value

###### checkBinding(view:ViewData, def: NodeDef, bindingIdx: number, value: any): boolean
- checks whether the index in the view's oldValues matches the current model state
- returns ```true``` if mismatch, ```false``` if no mismatch
  
  

#### Exploring the CheckAndUpdateFunction (_ck)
 
 This function is responsible for determining whether a change to a component model needs to be reflected in the DOM.
 If a change is found, it creates an object containing the binding keys from the node def, and pairs them with the model's current values (currVal_0, currVal_1...).
 
 Once the change object has been created, it renders each attribute key,value pair on the parent element
 
  
#### execComponentViewsAction()
  - this function iterates through view nodes looking for child views (component view nodes) 
  - if a child view is located, the checkAndUpdateView function is called and passed the child view as a new target
  - this process of checking nested child views continues until all child nodes are located and processed via change detection
  
  
#### execQueriesAction()
  -update ViewChildren query after view's nodes are updated

#### callInit(): transition from "afterContentInit" to "afterViewInit"


#### shiftInitState(): 

#### callLifeCycleHooks  
  
> example 
We have a click event handler listening to a button within our `<AppComponent>` template.  This button will toggle the `name` property on the AppComponent, which is being fed via property binding to its child `<hello>` component.
  
 A glance at the component instance, which is present as an instance in the ElementNode and the <hello> view.Component model, shows that Angular has created a temporary variable that co-exists with the known "name" property in the model:  `_name`.  The `_name` variable actually holds the new value.
  
The parent view of <hello> has already taken care of updating the model by updating its .oldValues array to reflect the change in the .name instance property.  It then rendered the DOM elements to reflect the current state of the model (appending the custom attribute name to the renderComponent node).  However, `<hello>`'s own view has not yet been updated to reflect the parent property interpolated within its template.
  
Only once the updateRenderer has run its course on the parent view does `checkAndUpdateView` call `execComponentViewsAction()`.  This function browses node definitions within `<AppComponent> ` and checks their flags to determine whether the node represents a component view; if it encounters a component view, it calls `checkAndUpdateView()` on that view.  This process will repeat on all subsequent child component views within this view until it reaches the end of that portion of the tree, and so on, and so forth, until a view is encountered that does not contain any child component views.  The overall process is depth first.






  
  
