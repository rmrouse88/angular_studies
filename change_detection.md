## Change Detection cycle

By default, change detection in Angular is triggered by almost any event you can think of:
- DOM events
- XML/fetch requests completing

Moreover, the location of the event within your application is not important.  An event that occurs in a deeply nested view at the furthest reaches of your application tree or close to the application root will both triggger change detection.

Before going any further, keep this in your mind:

<b><i>An Angular application is a tree of views</i></b>

#### applicationRef.tick()

A triggering event will cause the ```ApplicationRef.tick()``` method to fire.

This method will call the ```detectChanges()``` method of the <b><i>root</i></b> view.  Soon after, the first ```checkAndUpdateView()``` method is fired.

<b>TAKEAWAY:</b>Change detection starts at the application root and, more explicitly, <b><i>the root view</i></b>.

## checkAndUpdateView()
- One of the workhorses of both view initialization <i>and</i> change detection
- Manages the cycling of lifecycle hooks
#### markProjectedViewsForCheck()
#### Services.updateDirectives()
  directives are those 
#### execEmbeddedViewActions()
    there are two types of views:  
      1) Host Views - associated with a component
      2) Embedded Views - associated with a directive
#### callLifecycleHooksChildrenFirst
#### updateRenderer(_ck, _v)
  - _ck = check function, _v = view
  - most of the body of the updateRenderer is generated by Angular during the initial app load; it is populated with "hard-coded" variable declarations that are initialized on first load and during subsequent change detection passes to reflect current model state
  - makes sense that updateRenderer must be able to handle changes to the check function and the view during the application run-time (hence why they are passed as args)
  
 ```JavaScript
 //example of updateRenderer() body
 var co = _v.component;
 var currVal_0 = co.property0;
 var currVal_1 = co.property1;
 ...
 var currVal_N = co.propertyN;
 _ck(view, nodeIndex, argStyle, currVal_0, currVal_1...curVal_N);   
 ```
##### debugCheckRenderFn
  route to an appropriate checkAndUpdate function based on the checkType passed to debugUpdateRenderer
  1) debugCheckAndUpdateNode
  2) dbeugCheckNoChangesNode
  
#### debugCheckAndUpdateNode
  - First calls ```checkAndUpdateNode()``` to determine if there were changes to the model
  
  - so what the hell is it using to compare "old values" against new model values?
  
  - Well, remember that the directives in a view are updated prior to calling updateRenderer().  The directives attach themselves to the    'component' property of their parent node.  This loosely associates the model state with the view, but the view must then be updated to reflect these changes.  
  
  - if ```checkAndUpdateNode()``` returns ```true```, the interpolated properties have already been updated in the completed call to checkAndUpdateTextInline()
  
  - debugCheckAndUpdateNode now moves on to updating the attributes on the parent DOM element 
  
##### checkAndUpdateNode
  routes to one of: 
  - checkAndUpdateNodeInline - if argStyle = 'inline' 
  
  - checkAndUpdateNodeDynamic  - otherwise

###### checkAndUpdateNodeInline
  routes to a checkerAndUpdater based on the type of node
  
###### checkAndUpdateTextInline(view:ViewData, def: NodeDef, bindingIdx: number, value: any): boolean
  - giant switchboard checking all available binding indices associated with the current node's bindings
  - calls checkAndUpdateBinding for up to 10 binding values associated with a model
  - once finished updating the node's ```oldValues```, it moves on to rendering the updates in the associated DOM node

###### checkAndUpdateBinding(view:ViewData, def: NodeDef, bindingIdx: number, value: any): boolean
- calls checkBinding to establish a binding has changed
- if checkBinding returns ```true```, the view node's ```oldValues``` array is updated to include the changed value

###### checkBinding(view:ViewData, def: NodeDef, bindingIdx: number, value: any): boolean
- checks whether the index in the view's oldValues matches the current model state
- returns ```true``` if mismatch, ```false``` if no mismatch
  
  

#### Exploring the CheckAndUpdateFunction (_ck)
 
 This function is responsible for determining whether a change to a component model needs to be reflected in the DOM.
 If a change is found, it creates an object containing the binding keys from the node def, and pairs them with the model's current values (currVal_0, currVal_1...).
 
 Once the change object has been created, it renders each attribute key,value pair on the parent element
 
  
#### execComponentViewsAction()
  - this function iterates through view nodes looking for child views (component view nodes) 
  - if a child view is located, the checkAndUpdateView function is called and passed the child view as a new target
  - this process of checking nested child views continues until all child nodes are located and processed via change detection
  
  
#### execQueriesAction()
  -update ViewChildren query after view's nodes are updated

#### callInit(): transition from "afterContentInit" to "afterViewInit"


#### shiftInitState(): 

#### callLifeCycleHooks
  
  


```JavaScript

var myVar = 10;

```
