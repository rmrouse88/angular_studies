## Change Detection cycle

By default, change detection in Angular is triggered by almost any event you can think of:
- DOM events
- XML/fetch requests completing

Moreover, the location of the event within your application is not important.  An event that occurs in a deeply nested view at the furthest reaches of your application tree or close to the application root will both triggger change detection.

Before going any further, keep this in your mind:

<b><i>An Angular application is a tree of views</i></b>

# applicationRef.tick()

A triggering event will (after passing through several zones) fire ```ApplicationRef.tick()```.

This method will call the ```detectChanges()``` method of the <b><i>root</i></b> view.  Soon after, the first ```checkAndUpdateView()``` method is fired.

<b>TAKEAWAY:</b>Change detection starts at the application root and, more explicitly, <b><i>the root view</i></b>.

## checkAndUpdateView()
- One of the workhorses of both view initialization <i>and</i> change detection
- Manages the cycling of lifecycle hooks
#### markProjectedViewsForCheck()
#### Services.updateDirectives()
  directives are those 
#### execEmbeddedViewActions()
    there are two types of views:  
      1) Host Views - associated with a component
      2) Embedded Views - associated with a directive
#### callLifecycleHooksChildrenFirst
#### updateRenderer(_ck, _v)
  - _ck = check function, _v = view
  - most of the body of the updateRenderer is generated by Angular during the initial app load; it is populated with "hard-coded" variable declarations that are initialized on first load and during subsequent change detection passes to reflect current model state
  - makes sense that updateRenderer must be able to handle changes to the check function and the view during the application run-time (hence why they are passed as args)
  
 ```JavaScript
 //example of updateRenderer() body
 var co = _v.component;
 var currVal_0 = co.property0;
 var currVal_1 = co.property1;
 ...
 var currVal_N = co.propertyN;
 _ck(view, nodeIndex, argStyle, currVal_0, currVal_1...curVal_N);   
 ```
##### debugCheckRenderFn
  route to an appropriate checkAndUpdate function based on the checkType passed to debugUpdateRenderer
  1) debugCheckAndUpdateNode
  2) dbeugCheckNoChangesNode
  
#### debugCheckAndUpdateNode
  - First calls ```checkAndUpdateNode()``` to determine if there were changes to the model
  
  - so what the hell is it using to compare "old values" against new model values?
  
  - Well, remember that the directives in a view are updated prior to calling updateRenderer().  The directives attach themselves to the    'component' property of their parent node.  This loosely associates the model state with the view, but the view must then be updated to reflect these changes.  
  
  - if ```checkAndUpdateNode()``` returns ```true```, the interpolated properties have already been updated in the completed call to checkAndUpdateTextInline()
  
  - debugCheckAndUpdateNode now moves on to updating the attributes on the parent DOM element 
  
##### checkAndUpdateNode
  routes to one of: 
  - checkAndUpdateNodeInline - if argStyle = 'inline' 
  
  - checkAndUpdateNodeDynamic  - otherwise

###### checkAndUpdateNodeInline
  routes to a checkerAndUpdater based on the type of node
  
###### checkAndUpdateTextInline(view:ViewData, def: NodeDef, bindingIdx: number, value: any): boolean
  - giant switchboard checking all available binding indices associated with the current node's bindings
  - calls checkAndUpdateBinding for up to 10 binding values associated with a model
  - once finished updating the node's ```oldValues```, it moves on to rendering the updates in the associated DOM node

###### checkAndUpdateBinding(view:ViewData, def: NodeDef, bindingIdx: number, value: any): boolean
- calls checkBinding to establish a binding has changed
- if checkBinding returns ```true```, the view node's ```oldValues``` array is updated to include the changed value

###### checkBinding(view:ViewData, def: NodeDef, bindingIdx: number, value: any): boolean
- checks whether the index in the view's oldValues matches the current model state
- returns ```true``` if mismatch, ```false``` if no mismatch
  
  

#### Exploring the CheckAndUpdateFunction (_ck)
 
 This function is responsible for determining whether a change to a component model needs to be reflected in the DOM.
 If a change is found, it creates an object containing the binding keys from the node def, and pairs them with the model's current values (currVal_0, currVal_1...).
 
 Once the change object has been created, it renders each attribute key,value pair on the parent element
 
  
#### execComponentViewsAction()
  - this function iterates through view nodes looking for child views (component view nodes) 
  - if a child view is located, the checkAndUpdateView function is called and passed the child view as a new target
  - this process of checking nested child views continues until all child nodes are located and processed via change detection
  
  
#### execQueriesAction()
  -update ViewChildren query after view's nodes are updated

#### callInit(): transition from "afterContentInit" to "afterViewInit"


#### shiftInitState(): 

#### callLifeCycleHooks  
  
> example <br>
We have a click event handler listening to a button within our `<AppComponent>` template.  This button will toggle the `name` property on the AppComponent, which is being fed via property binding to its child `<hello>` component.

after several tasks are run through ngZone, there will be a call made to `ApplicationRef.tick()`.  ApplicationRef.tick() will call `CheckAndUpdateView()` on the applications _viewRef, and start the process.  


after encountering the first directive in the view, Angular routes through several checkAndUpdateView routers before finally getting to work.  Once it arrives at the proper `checkAndUpdateView()`, it begins by determining whether the value generated by evaluating the contents of the updateDirective function body matches the appropriate index of the `oldValues` array stored on the view.  

At this point of the change detection cycle, the component's state has not yet been updated to reflect a change in value:  The parent view's `oldValues` array, the component's render element, or the component's directive node.  

But we can see that Angular is storing that property almost as a temp variable called `_name`.  

```JavaScript
HelloComponent
name: (...)
_name: "Angular"
__proto__: Object
```

After Angular confirms that our directive has indeed changed, it fires the `updateProp` function to ensure the model is updated.  Since directives are not always associated with a view (i.e. they can be created as a standalone entity, or generated as a byproduct of creating a component), Angular checks whether it is associated with a component via nodeFlag.  If it is, it will find the component's render element via a parentNode property being carried by the component's directive.  

The directive instance is then formally updated to reflect a change in value (you can watch Angular adjusting the value of your instance, and this is the point at which any setters will fire).  <b><i>Once the instance is adjusted, the directive node and the component state carried by the component's view both reflect the change</i></b>.  Angular checks whether the instance has an `onChanges` lifecycle hook, at which point it will add the property to a simpleChanges object that will be sent.  Finally, the `oldValues` array of the directive's parent view is updated.    

Once the above logic is completed, and assuming there has been a change, Angular also updates the property binding and interpolation changes on renderElement nodes (ensure that Angular-generated attributes in the parent view reflect the new state of the model).

#### BEHOLD, the debug-mode double-check that no changes have occured since the first change detection cycle was completed.

```JavaScript
  tick(): void {
    if (this._runningTick) {
      throw new Error('ApplicationRef.tick is called recursively');
    }

    const scope = ApplicationRef._tickScope();
    try {
      this._runningTick = true;
      this._views.forEach((view) => view.detectChanges());
      if (this._enforceNoNewChanges) {
        this._views.forEach((view) => view.checkNoChanges());
      }
```


```JavaScript
export function checkNoChangesView(view: ViewData) {
  markProjectedViewsForCheck(view);
  Services.updateDirectives(view, CheckType.CheckNoChanges);
  execEmbeddedViewsAction(view, ViewAction.CheckNoChanges);
  Services.updateRenderer(view, CheckType.CheckNoChanges);
  execComponentViewsAction(view, ViewAction.CheckNoChanges);
  // Note: We don't check queries for changes as we didn't do this in v2.x.
  // TODO(tbosch): investigate if we can enable the check again in v5.x with a nicer error message.
  view.state &= ~(ViewState.CheckProjectedViews | ViewState.CheckProjectedView);
}
```


 A glance at the component instance, which is present as an instance in the ElementNode and the <hello> view.Component model, shows that Angular has created a temporary variable that co-exists with the known "name" property in the model:  `_name`.  The `_name` variable actually holds the new value.
  
The parent view of <hello> has already taken care of updating the model by updating its .oldValues array to reflect the change in the .name instance property.  It then rendered the DOM elements to reflect the current state of the model (appending the custom attribute name to the renderComponent node).  However, `<hello>`'s own view has not yet been updated to reflect the parent property interpolated within its template.
  
Only once the updateRenderer has run its course on the parent view does `checkAndUpdateView` call `execComponentViewsAction()`.  This function browses node definitions within `<AppComponent> ` and checks their flags to determine whether the node represents a component view; if it encounters a component view, it calls `checkAndUpdateView()` on that view.  This process will repeat on all subsequent child component views within this view until it reaches the end of that portion of the tree, and so on, and so forth, until a view is encountered that does not contain any child component views.  The overall process is depth first.






  
  
